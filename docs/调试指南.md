# 多屏模式调试指南

## 当前问题排查

### 问题 1：摇杆控制不工作

**现象**：
- 摇杆移动时机器人3D模型没有反应
- 后端日志显示 "Cannot publish to robot_3d_command: not connected"

**排查步骤**：

1. **检查摇杆是否被识别**
   ```
   打开浏览器控制台，查看是否有以下日志：
   [PeripheralController] 更新移动速度: {linearX: xxx, linearY: 0, angularZ: xxx}
   ```

2. **检查 Robot3DViewer 是否收到更新**
   ```
   控制台应该显示：
   [Robot3DViewer] 收到移动速度更新: {linearX: xxx, linearY: 0, angularZ: xxx}
   [Robot3DViewer] 速度大小: xxx 是否有移动: true/false
   ```

3. **检查 Zustand store 是否工作**
   ```javascript
   // 在控制台运行：
   window.__ZUSTAND_STORES__ // 查看所有 stores
   ```

**可能的原因**：
- PeripheralController 没有启用（`enablePeripherals` 未设置为 true）
- Zustand store 没有正确连接
- Robot3DViewer 的 useEffect 依赖项错误

**临时解决方案**：
1. 刷新页面重新初始化
2. 检查 Screen0 的 ControlPanel 是否设置了 `enablePeripherals={true}`

---

### 问题 2：返回机器人列表时其他屏幕不退回

**现象**：
- 主控屏点击"更换机器人"后回到机器人列表
- 其他屏幕（Screen1/2/3）仍然显示之前的内容，没有回到"等待选择机器人"界面

**排查步骤**：

1. **检查主控屏的事件发送**
   ```
   主控屏控制台应该显示：
   [MultiScreenLayout] Deselecting robot from screen: 0
   [MultiScreenLayout] Robot deselected, state cleared
   ```

2. **检查后端事件广播**
   ```
   后端日志应该显示：
   [WebSocketService] [INFO] Client xxx deselected robot
   [WebSocketService] [INFO] Broadcasted robot_deselected to all clients
   ```

3. **检查其他屏幕的事件接收**
   ```
   其他屏幕控制台应该显示：
   [MultiScreenLayout] Robot deselected event received, clearing state for screen: X
   [MultiScreenLayout] State cleared, should show waiting screen
   [MultiScreenLayout] renderScreen called, screenId: X, selectedRobotId: null, isAuthenticated: true
   [MultiScreenLayout] No robot selected, showing waiting/selection screen for screen: X
   ```

4. **检查 localStorage 同步**
   ```javascript
   // 在控制台运行：
   localStorage.getItem('robot_cockpit_selected_robot') // 应该是 null
   localStorage.getItem('robot_cockpit_robot_updated')   // 应该有时间戳
   ```

**可能的原因**：
- WebSocket 连接断开（其他屏幕没有收到事件）
- localStorage 同步失败（跨窗口）
- 状态更新了但界面没有重新渲染

**临时解决方案**：
1. 在其他屏幕刷新页面
2. 检查所有屏幕的 WebSocket 连接状态

---

### 问题 3：主控屏切换到视频界面后看不到视频

**现象**：
- 点击"视频视角"按钮后，三个视频画布区域显示黑屏或空白
- 控制台显示 "[VideoPlayer] 请求摄像头访问..."

**排查步骤**：

1. **检查 VideoPlayer 状态**
   ```
   控制台应该显示（每个 VideoPlayer 一次）：
   [VideoPlayer] screenId=X, compact=true, isVideoLoading=true/false, videoError=null/xxx, isVideoEnabled=true, useSimulation=true/false
   ```

2. **检查摄像头权限**
   ```
   - 浏览器地址栏左侧是否有摄像头图标？
   - 是否弹出摄像头权限请求？
   - 权限是否被拒绝？
   ```

3. **检查视频容器高度**
   ```javascript
   // 在控制台运行（切换到视频界面后）：
   document.querySelector('.view-section-multi').offsetHeight
   document.querySelector('.view-left-arm-multi').offsetHeight
   document.querySelector('.video-container').offsetHeight
   ```

4. **检查 CSS 是否加载**
   ```javascript
   // 在控制台运行：
   getComputedStyle(document.querySelector('.view-left-arm-multi')).height
   getComputedStyle(document.querySelector('.view-left-arm-multi')).minHeight
   ```

**可能的原因**：
- 摄像头权限被拒绝，模拟视频初始化失败
- 视频容器高度为 0
- CSS 没有正确加载或被覆盖
- VideoPlayer 一直处于加载状态

**临时解决方案**：
1. 允许摄像头权限（如果提示）
2. 刷新页面重新初始化
3. 检查是否有 CSS 加载错误

---

## 通用调试技巧

### 1. 查看 WebSocket 连接状态

```javascript
// 在任何屏幕的控制台运行：
window.__websocket_status__ // 如果暴露了全局变量
```

### 2. 查看 Zustand Store 状态

```javascript
// 查看 robot3DStore
import { useRobot3DStore } from './stores/robot3DStore';
const state = useRobot3DStore.getState();
console.log('Robot3D State:', state);
```

### 3. 手动触发状态更新

```javascript
// 手动清除机器人选择
localStorage.removeItem('robot_cockpit_selected_robot');
localStorage.setItem('robot_cockpit_robot_updated', Date.now().toString());
window.dispatchEvent(new CustomEvent('robot_cockpit_robot_update'));
```

### 4. 检查事件监听器

```javascript
// 查看某个元素上的事件监听器
getEventListeners(document); // Chrome DevTools
```

---

## 已知的调试日志

### 正常启动流程

**主控屏（Screen0）：**
```
[MultiScreenLayout] renderScreen called, screenId: 0, selectedRobotId: null, isAuthenticated: true
[MultiScreenLayout] No robot selected, showing waiting/selection screen for screen: 0
```

**其他屏幕（Screen1/2/3）：**
```
[MultiScreenLayout] renderScreen called, screenId: X, selectedRobotId: null, isAuthenticated: true
[MultiScreenLayout] No robot selected, showing waiting/selection screen for screen: X
```

### 选择机器人后

**所有屏幕：**
```
[MultiScreenLayout] Storage changed for robot selection, screen: X, new value: robot_xxx
或
[MultiScreenLayout] Robot update event received, screen: X, new value: robot_xxx
[MultiScreenLayout] renderScreen called, screenId: X, selectedRobotId: robot_xxx, isAuthenticated: true
```

### 取消选择机器人后

**主控屏：**
```
[MultiScreenLayout] Deselecting robot from screen: 0
[MultiScreenLayout] Robot deselected, state cleared
[MultiScreenLayout] Robot deselected event received, clearing state for screen: 0
[MultiScreenLayout] State cleared, should show waiting screen
```

**其他屏幕：**
```
[MultiScreenLayout] Robot deselected event received, clearing state for screen: X
[MultiScreenLayout] State cleared, should show waiting screen
[MultiScreenLayout] renderScreen called, screenId: X, selectedRobotId: null, isAuthenticated: true
[MultiScreenLayout] No robot selected, showing waiting/selection screen for screen: X
```

---

## 下一步行动

1. **收集日志**
   - 打开所有屏幕的控制台
   - 执行操作（摇杆控制、切换界面、取消选择等）
   - 复制所有相关日志

2. **验证 WebSocket 连接**
   - 检查后端日志
   - 确认所有客户端已注册
   - 确认事件广播成功

3. **检查样式问题**
   - 使用浏览器开发者工具检查元素
   - 查看计算后的样式
   - 检查是否有 CSS 冲突

4. **如果问题持续**
   - 提供完整的控制台日志
   - 提供后端日志
   - 提供浏览器版本和操作系统信息
   - 提供复现步骤
